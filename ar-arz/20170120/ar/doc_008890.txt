<doc id="534673" title="سي++" url="https://ar.wikipedia.org/wiki?curid=534673">
سي++

سي++ (تنطق: "سي بلس بلس") هي لغة برمجة كائنية، متعددة أنماط البرمجة، مصرفة، سكونية الأنماط. وتضم العديد من ميزات لغات البرمجة عالية المستوى ومنخفضة المستوى. بدأ تطوير هذه اللغة كامتداد للغة سي تحت اسم (سي مع الصفوف) من قبل بيارن ستروستروب في مختبرات بل عام 1979 وتم إضافة العديد من الميزات الأخرى لاحقاً وتغير الاسم عام 1983 ليصبح سي++ من باب الدعابة عبر استخدام معامل الزيادة لجانب اسم لغة سي تأكيداً على أنها "التالي للغة سي".

تعتبر سي++ إحدى اللغات الأكثر شيوعاً وقد استخدمت على نطاق واسع في بناء أنظمة التشغيل والتعامل مع البنية الصلبة للحاسوب ابتداءً من الأنظمة البرمجية وبرامج المستخدم، مروراً بمشغلات الأجهزة والأنظمة المضمنة وانتهاءً بالمخدمات عالية الأداء وبرامج التسلية كالألعاب الفيديوية نظراً لقدرة تصريفها إلى كود لغة تجميع شديد الفعالية. أحد أكثر استخدامات سي++ إثارةً للإعجاب حسب رأي ستروستروب هو استخدام سي++ في كتابة قسم كبير من أنظمة القيادة الأوتوماتيكية للعربات التي تجولت على سطح المريخ (مارس روفر) .

يوجد العديد من المصرفات التجارية والمفتوحة المصدر لـسي++، من هذه المصرفات مشروع جنو، مصرفات إنتل، مصرفات مايكروسوفت، مصرفات استديو أوراكل سولاريس، مصرفات ديجيتال مارس، ومصرفات إيمباركاديرو تكنولوجيز. لقد أثرت لغة سي++ بالعديد من لغات البرمجة الشائعة مثل سي شارب وجافا. في حين تستخدم لغات أخرى كلغة سي-الكائنية نحواً شديد الاختلاف ومقاربة مختلفة في إضافة الصفوف إلى سي.

بدأت سي++ كتحسين للغة سي، أولاً عبر إضافة الصفوف ومن ثم التوابع الظاهرية وتحميل المعاملات الحسابية والوراثة المتعددة والقوالب ومعالجة الاستئناءات بالإضافة إلى ميزات الأخرى. بعد سنوات من التطوير تم تصديق سي++ عام 1998 كمعيار آيزو ذو الاسم ISO/IEC 14882:1998. وفي عام 2003 تم تعديل المعيار وفقاً لوثيقة التصحيح التقنية ISO/IEC 14882:2003. يتضمن المعيار الحالي ISO/IEC 14882:2011 مجموعة من الميزات التي تم الاتفاق عليها ونشرها كمعيار جديد من المنظمة الدولية للمعايير في أيلول 2011 والذي عُرف سابقاً باسم سي++ 11.

بدأ بيارن ستروستروب العمل على مشروعه سي مع الصفوف (C with Classes) عام 1979، وقد استلهم فكرة هذا المشروع أثناء عمله على أطروحة الدكتوراه حيث قضى وقتاً طويلاً بالبرمجة. لقد اكتشف ستروستروب أن العديد من ميزات لغة سيمولا ملائمة في الحقيقة لتطوير برمجيات ضخمة إلا أن بطء أداء التطبيقات المكتوبة بهذه اللغة كان يحول دون استخدامها بشكل عملي، وفي الوقت نفسه كانت تتمتع اللغة لغة البرمجة الأساسية المختلطة بأداء جيد إلا أنها منخفضة المستوى وبالتالي يصعب استخدامها في تطوير برمجيات ضخمة، قاد هذا الاكتشاف ستروستروب إلى فكرة تطوير لغة برمجة جديدة تجمع المزايا الحسنة من هاتين اللغتين.

واجه ستروستروب لاحقاً مشكلة تحليل نواة نظام يونكس فيما يتعلق بالحوسبة الموزعة خلال عمله في مختبرات بل وتذكر المعضلات التي واجته خلال عمله على أطروحته فعقد العزم على تحسين لغة سي بإضافة ميزات شبيهة بتلك الموجودة في لغة سيمولا. اختار ستروستروب لغة سي لكونها لغة عمومية، سريعة، محمولة، وشائعة الاستخدام. لقد ألهمت ستروستروب -بالإضافة إلى سي وسيمولا- عدد من اللغات الأخرى وهي ِألغول 68 ولغة معرِّفة(ML) وكلو (لغة برمجة) وأيدا.

عمل ستروستروب على تطوير مصرف اسمه «سي فرونت» يقوم بتصريف كود سي++ إلى كود سي مكافئ، وقد قام من خلاله بإضافة بعض الميزات الجديدة إلى لغة سي مثل الصنوف، الصنوف المشتقة، التنميط القوي ، التضمين ، والقيم الافتراضية. تم طرح أول إصدار تجاري من سي++ في 14 تشرين الأول 1985.

في عام 1983 تم تغيير اسم اللغة من «سي مع الصنوف» إلى سي++ (حيث أن ++ هو معامل الزيادة بلغة سي) كما تم إضافة مجموعة من الميزات متل التوابع الظاهرية، التحميل الزائد للمعاملات والتوابع، المراجع ، الثوابت، التحكم بالذاكرة المدار من قبل المستخدم، تحقق محسن من الأنماط، والتعليقات السطرية باستخدام خطين مائلين (//) على نمط لغة البرمجة الأساسية المختلطة. في عام 1985 نُشر الإصدار الأول من كتاب لغة البرمجة سي++ ليزود المبرمجين بأحد أهم المراجع عن هذه اللغة في وقت لم توصّف فيه اللغة "بعد" كمعيار رسمي. عام 1989 نُشر الإصدار 2.0 من الكتاب وعام 1991 نٌشر الإصدار الثاني المحدث منه. اشتملت الميزات الجديدة على الوراثة المتعددة، الصنوف المجردة ، التوابع الأعضاء السكونية ، التوابع الأعضاء الساكنة ، والأعضاء المحمية. عام 1990 نُشر دليل سي++ المرجعي التفصيلي (The Annotated C++ Reference Manual) وكان حجر الأساس لمعيار اللغة المستقبلي. اشتملت الميزات اللاحقة على القوالب والاستثناءات وفضاءات الأسماء وتحويلات جديدة بين الأنماط والنمط البولياني.

ترافق تطور لغة سي++ مع تطور المكتبة المعيارية. إن مكتبة الدخل والخرج (I/O stream) هي أولى الإضافات إلى المكتبة المعيارية، توفر هذه المكتبة بدائلاً لتوابع الدخل والخرج المعتادة في لغة سي مثل codice_1 وcodice_2. تعتبر مكتبة القوالب القياسية (Standard Template Library) إحدى أهم الإضافات إلى المكتبة المعيارية من بين الإضافات اللاحقة الكثيرة المتتالية. تتميز لغة سي++ عن باقي اللغات بقلة عدد الكلمات المفتاحية حيث أن الوظيفية الأساسية تم إدراجها في المكتبة المعيارية على غرار لغة سي.

تسمى سي++ أحياناً لغة هجينة وذلك بسبب توفيرها العديد من النماذج البرمجة المختلفة وإتاحتها استخدام هذه النماذج مع بعضها البعض كاستخدام النموذج الإجرائي والنموذج الغرضي التوجه أثناء كتابة نفس البرنامج. لقد أثارت إمكانية كتابة برامج إجرائية باستخدام سي++ بعض الجدل على اعتبار أنه من المفترض كتابة برامج غرضية التوجه لدى استخدام سي++ (وإلا لتم استخدام سي مثلاً). بكل الأحوال فإنه من المعتاد دمج النموذجين الإجرائي والغرضي التوجه لدى كتابة برنامج ما. وغالباً ما يسبب هذا بعض المشاكل أثناء فحص الكود أو إتمام كتابة الكود من قبل مبرمج آخر .

لا تزال سي++ قيد الاستخدام بشكل واسع وتعتبر إحدى اللغات المفضلة في تطوير التطبيقات الاحترافية .

يقول ستروستروب: "يؤكد الاسم الطبيعة التطورية للتغيرات المحدثة على لغة سي" . أثناء مرحلة التطوير تم تسمية سي++ غير رسميًّا بِـ«سي الجديدة» ثم تغير الاسم إلى «سي مع الصفوف» .
يعود الفضل في التسمية النهائية (سي++) إلى ريك ماسيتي (أواسط عام 1983) وقد استخدم هذه التسمية لأول مرة في كانون الأول عام 1983. عندما سُؤل ماسيتي عام 1992 عن سبب تسمية اللغة بهذا الاسم أجاب أنه قام بذلك من باب المزاح. ويعود أصل الاسم إلى استخدام معامل الزيادة (++) من لغة سي والذي يقوم بزيادة قيمة المتغير المسند له والاستخدام الشائع لرمز (+) للدلالة على حصول تحسين في برنامج حاسوبي. الدعابة تكمن في أن الاسم نفسه يحتوي على خطأ: ذلك أن استخدام الزيادة اللاحقة يسبب زيادة المتحول بعد تقييم قيمة المتحول السابقة (على عكس الزيادة السابقة ) بمعنى أن لغة سي++ ليست أفضل من لغة سي وإلا فقد كان من الأجدر استخدام الزيادة السابقة بحيث يصبح اسم اللغة سي++ بدلاً من استخدام الزيادة اللاحقة كما في الاسم الحالي..

لا توجد لغة باسم «سي+» علماً أنه توجد لغة مختلفة تماماً اسمها +ABCL/c. وهنالك بعض اللغات التي سميت بشكل قريب من سي++ أشهرها لغة سي– ولغة سي شارب.

قامت لجنة تعيير ++C (مجموعة عمل ISO/IEC JTC1/SC22/WG21) عام 1998 بتعيير لغة ++C ونشرت المعيار ISO/IEC 14882:1998 (المعروف بشكل غير رسمي باسم C98). بعد نشر المعيار ببعض السنوات تفحصت اللجنة تقارير عن أخطاء ومشاكل المعيار السابق ونشرت عام 2003 إصداراً مصححاً من معيار ++C اسمه ISO/IEC 14882:2003. نُشر تقرير تقني عام 2005 اسمه (التقرير التقني 1 ، أو اختصاراً TR1) . وصّف التقرير مجموعة من الامتدادات للمكتبة المعيارية -على الرغم من أنه ليس جزءاً من معيار اللغة- بحيث يتم اعتماد هذه الامتدادات في الإصدار التالي من ++C.

C++11 هو المراجعة الأحدث لمعيار ++C وقد عرف سابقاً باسم C++0x وتمت المصادقة عليه من قبل ISO/IEC في 12 آب 2011 ونشر باسم 14882:2011 . وهنالك خطط لمراجعة طفيفة (C++14) وأخرى رئيسية (C++17) في المستقبل .

في كتاب "تصميم وتطوير لغة ++C" (ستروستروب، 1994) يصف بيارن ستروستروب بعض القواعد التي استلهم منها تصميم ++C:
في كتاب "النموذج الكائني للغة ++C" (ليبمان، 1996) يشرح الكاتب إمكانية تحويل مصرفات ++C العبارات البرمجية إلى توضعات داخل الذاكرة. إلا أن هذا لا يمنع بالطبع مصممي المصرفات من اعتماد طرقهم الخاصة في كتابة مصرفات متوافقة مع المعيار المرجعي ++C.

يتكون المعيار C++98 من قسمين: النواة وهي اللغة ومكتبة ++C المعيارية؛ تتضمن هذه المكتبة مكتبة القوالب المعيارية (STL) وإصداراً معدلاً بشكل طفيف من مكتبة C المعيارية. يوجد العديد من مكتبات ++C التي ليست جزءاً من المعيار، كما أنه يمكن كتابة العديد من المكتبات بلغات أخرى مثل BASIC أو C أو Fortran أو حتى Pascal بناءً على توصيف الربط . على كل الأحوال فإن دعم هذه المكتبات الإضافية يعتمد بشكل كامل على دعم المصرف لها فقط ذلك أنها ليست جزءاً من المعيار.

تتضمن مكتبة ++C المعيارية مكتبة C المعيارية مع بعض التعديلات بهدف أمثلتها مع لغة ++C. هنالك جزء كبير من مكتبة ++C مبني على مكتبة القوالب المعيارية. توفر هذه المكتبة العديد من الأدوات كالحاويات (على سبيل المثال codice_3 وcodice_4) والتكرارات التي توفر تعاملاً مع الحاويات شبيهاً بطريقة التعامل التقليدية مع المصفوفات من ناحية الولوج إلى العناصر وتوفير العديد من الخوارزمات كالترتيب والبحث. بالإضافة إلى ذلك يوجد العديد من أنماط البيانات المجردة كـcodice_5 وcodice_6 وcodice_7 وcodice_8 ويصدّر كل منها واجهات موحّدة تمكن التعامل معها بسهولة. إذ يمكن على سبيل المثال استخدام القوالب لكتابة خوارزمية مجردة يمكنها التعامل مع أي نوع من الحاويات أو السلاسل باستخدام التكرارات. يتم الولوج إلى مزايا هذه المكتبة كما في لغة C من خلال استخدام موجه التضمين codice_9 من أجل تضمين الملفات المعيارية الرأسية. توفر ++C مجموعة من الملفات الرأسية عددها 105، 27 منها لم تعد قيد التطوير (مهملة ).

كانت مكتبة القوالب المعيارية STL بالأساس مكتبة مطورة من طرف ثالث بالبداية كان HP وتحولت لاحقاً إلى SGI قبل أن تدرج بشكل رسمي ضمن معبار ++C. ألكسندر ستيبانوف هو المعماري الأساسي لهذه المكتبة التي أتت حصيلة اختباره للخوارزميات والحاويات المجردة سنواتٍ طويلة. لما بدأ ستيبانوف استخدام لغة ++C سرعان ما اكتشف أنها اللغة المناسبة لكتابة الخوارزميات المجردة (مثل خوارزمية codice_10 الخاصة بـSTL) والتي يمكنها العمل بسرعة أكبر من قريناتها كخوارزمية codice_11 مثلاً من مكتبة C القياسية ويعود الفضل في ذلك إلى مزايا لغة ++C كالتضمين والربط وقت التصريف والتي تغني عن استخدام المؤشرات إلى التوابع.

لا يشير المعيار إلى هذه مكتبة القوالب المعيارية باسم "STL" ذلك أنها جزء فقط من المكتبة المعيارية إلا أن هذا الاسم يستخدم بشكل شائع للتمييز عن باقي محتويات المكتبة المعيارية (مثل مكتبة الدخل والخرج المعيارية، عولمة البرنامج ، التشخيص، مكتبة C المعيارية المعدّلة، إلخ).

توفر العديد من مصرفات ++C تطبيقاً لمكتبة ++C المعيارية بما فيها STL وهنالك أيضاً تطبيقات خاصة بالمصرف من STL مثل STLPort. توجد العديد من المشاريع التي توفر إصدارات مخصصة من مكتبة ++C المعيارية وSTL ملائمة لأهداف تصميمية عديدة. وقد كان هناك رجل اسمه إبراهيم عمر باكلكا هذا الرجل يعتبر نابغة في الاختراقات الحاسوبية ويعد من أكبر مستخدمي هذه اللغة

ترث لغة ++C نحو لغة C، فيما يلي إصدار من برنامج أهلاً بالعالم مكتوب بهذه اللغة من قبل بيارن ستروستروب ، يتم في هذا البرنامج استخدام مجرى الخرج الموجود في مكتبة ++C المعيارية من أجل كتابة عبارة !Hello, World إلى الخرج المعياري.

من الجدير بالملاحظة أن فشل التابع في إعادة قيمة يسبب سلوكاً غير معرف في حال كان توقيعه يشير إلى إعادة قيمة من نمط مخالف للنمط void (تقدم المصرفات عادة معلومات كافية لتشخيص مشكلة كهذه). الاستثناء الوحيد لهذه القاعدة هو التابع codice_12 والذي يعيد ضمنياً القيمة 0 في حال عدم الإشارة صراحة إلى ذلك.

توفر لغة ++C ما يزيد عن 35 معاملاً بما فيها المعاملات الحسابية الأساسية ومعاملات التلاعب بالبتات ومعاملات إزالة الأدلة (الخاصة بالتعامل مع المؤشرات) ومعاملات المقارنة والمعاملات المنطقية وغيرها. يمكن تحميل معظم المعاملات بشكل زائد من قبل المستخدم مع بعض الاستئناءات الجديرة بالملاحظة مثل معاملات الولوج إلى الأعضاء (. و .*) وكذلك المعاملات الشرطية. تعتبر ميزة تحميل المعاملات بشكل زائد حجر الأساس في تمكين استخدام الأنماط المعرفة من قبل المستخدم إضافة إلى تسهيل استخدام الأنماط المتاحة من اللغة نفسها (بحيث أن المستخدم لا يستطيع تمييز الفوارق بينها). يعتبر التحميل الزائد للمعاملات أساسياً أيضاً في العديد من الميزات المتقدمة للبرمجة باستخدام ++C كتقنية المؤشرات الذكية. من الجدير بالملاحظة أن التحميل الزائد للمعاملات لا يغير من قواعد أسبقية المعاملات ولا يغير من عدد المتحولات التي يتعامل معها المعامل (يمكن على كل الأحوال للمعامل أن يهمل بعض المتحولات، إلا أن المتحولات سيتم تقييمها قبل تنفيذ المعامل). إن التحميل الزائد لمعاملات "&amp;&amp;" و"||" يفقدها خاصية تقييم قصر الدارة التي تكسبها فعالية في الأداء.

تدعم ++C أربع طرق لإدارة الذاكرة:
إن تمكين المستخدم من إدارة الذاكرة بشكل كامل شبيه بلغة C على عكس لغات البرمجة التي تعمد إلى إخفاء تفاصيل كهذه عن المبرمج مثل لغة Java وPerl وPHP وRuby.

تتيح قوالب ++C البرمجة العمومية . تدعم ++C كلاً من قوالب الصفوف وقوالب التوابع. يمكن إعطاء القوالب ثلاث أنواع من البارامترات: أنماط، ثوابت معرفة وقت التصريف، وقوالب أخرى. يتم تخصيص القوالب وبناء نماذج منها وقت التصريف. لبناء قالب يقوم المصرف باستبدال بارامترات القالب بوسطاء محددة من أجل توليد تابع حقيقي أو نموذج عن صف.

بعض الاستبدالات غير ممكنة إلا أنها لا تولد أخطاءً، يعود الفضل في ذلك إلى سياسة تقرير التحميل الزائد للقوالب التي توصف بالعبارة التالية: "الفشل في الاستبدال ليس خطأ" (SFINAE) تحاول هذه السياسة استنباط الاستبدالات الصحيحة حتى وإن قادت بعض الاستنباطات إلى استبدالات خاطئة. تقدم القوالب أداة قوية يمكن استخدامها للبرمجة العمومية والميتا-برمجة باستخدام القوالب كذلك يمكن استخدامها في أمثَلة الكود إلا أن هذه القوة لا تأتي بدون تكلفة. قد تزيد القوالب من حجم الكود ذلك أن كل تخصيص للقالب ينتج نسخة من كود القالب: إلا أن نسخة توليد نسخة من أجل كل مجموعة من وسطاء القالب يكافئ إلى حد ما نفس حجم الكود الناتج من كتابتها بشكل يدوي. إن هذا السلوك مخالف للكائنات العمومية التي تعمل وقت التنفيذ والمدعومة في عدد من اللغات (مثل لغة Java) حيث يحذف النمط وقت التصريف ويحفظ جسم وحيد للقالب ليتم استخدامه وقت التنفيذ.

تختلف القوالب عن الماكروز بعدة نواحٍ: على الرغم من أن كلا الميزتين توفران تصريفاً شرطياً إلا أن القوالب ليست محدودة بالاستبدال اللفظي فقط حيث أن لديها اطلاع على معاني ونظام التنميط الخاص باللغة بالإضافة إلى معرفتها بتعاريف الأنماط وقت التصريف كما يمكنها القيام بالعديد من المهام العالية المستوى مثل إمكانية ضبط التدفق برمجياً من خلال تقييم البارامترات ذات الأنماط المعروفة قسراً. لدى الماكرو القدرة على القيام بالتحكم الشرطي في التصريف بناءً على شروط محددة سلفاً إلا أنها غير قادرة على خلق أنماط جديدة أو استدعاء نفسها ذاتياً أو القيام بتقييم الأنماط ويبقى تأثيرها محدوداً باستبدال السلاسل النصية و(عدم)تضمين النصوص مباشرة قبل التصريف. بمعنى آخر تستطيع الماكروز التحكم بتدفق التصريف بناءً على رموز معرفة سابقاً إلا أنها -على خلاف القوالب- غير قادرة على إنشاء رموز جديدة بمفردها. تعتبر القوالب أداة لتحقيق تعدد الأشكال السكوني والبرمجة العمومية.

إضافة لما سبق تجدر الإشارة إلى أن القوالب هي ميكانيكية وقت-التصريف خاصة بلغة ++C تتمتع بميزة أنها تورينغ-كاملة بمعنى أنه يمكن استخدام القوالب لكتابة برامج يمكنها القيام قبل التنفيذ بكافة الاحتسابات التي يمكن القيام بها باستخدام أي برنامج حاسوبي.

يمكن تلخيص ما سبق بالقول أن القوالب هي توابع أو صفوف مضاف إليها بارامترات تعمل وقت التصريف وتكتب بدون معرفة مسبقة بالوسطاء المستخدمة لتحقيق نماذج مخصصة منها. إن الكود الناتج من تخصيص القالب مكافئ للكود المكتوب بشكل يدوي خصيصاً من أجل الوسطاء الممررة. بهذه الطريقة توفر القوالب طريقة لفصل الجوانب العمومية والقابلة للتطبيق على نطاق واسع على شكل توابع وصفوف (مرمزةً كقوالب) عن الجوانب المخصصة (مرمزةً كبارامترات للقوالب) دون أن يسبب هذا التجريد خسارة في الأداء.

تضيف ++C مزايا البرمجة الكائنية التوجه (OOP) إلى لغة C، فقد تم إضافة الصفوف التي تقدم بدورها الميزات كائنية التوجه الأربعة الشائعة في أغلب لغات البرمجة الكائنية التوجه (وكذلك بعض اللغات الغير كائنية التوجه): التجريد، التغليف، الوراثة، تعدد الأشكال. إحدى أهم ميزات صفوف ++C التي تفرقها عن باقي اللغات هي دعم الهوادم الحتمية والتي توفر بدورها دعماً لمفهوم استحواذ المصدر عبر تهيئته (RAII) .

التغليف هو إخفاء المعلومات بهدف ضمان أن بنى المعطيات والمعاملات سيتم استخدامها بالشكل المحدد ولجعل نموذج استخدامها أكثر وضوحاً بالنسبة للمطور. توفر لغة ++C إمكانية تعريف الصفوف والتوابع كتقنيات بدائية للتغليف. يمكن لأعضاء الصف أن يعرف "عاماً" أو "محمياً" أو "خاصاً" لتطبيق مفهوم التغليف صراحةً. يمكن لأي تابع الولوج إلى عضو عام في حين لا يمكن الولوج إلى الأعضاء الخاصة إلا من قبل التوابع الأعضاء بالإضافة إلى التوابع والصفوف "الأصدقاء" أي تلك الممنوحة صلاحية الولوج إلى الأعضاء الخاصة بالصف (باستخدام الكلمة المفتاحية codice_18). يمكن الولوج للعضو المحمي من قبل كافة أعضاء الصفوف الوارثة إضافة إلى الصف نفسه وجميع "أصدقاءه".

يشير المبدأ الكائني التوجه إلى أنه في حال كان لدى تابع صلاحية الولوج إلى البنية الداخلية لنمط ما وجب تغليف هذا التابع ضمن تعريف النمط. تدعم ++C هذا المبدأ (من خلال التوابع الأعضاء والتوابع الصديقة) إلا أنها لا تجبر المبرمج على تطبيقه: إذ يمكن للمبرمج أن يعرف أجزاءً من تمثيل النمط كأعضاء عامة بحيث يمكن الولوج إليها من قبل كيانات خارجية ليست بالضرورة جزءاً من تمثيل النمط. لهذا السبب لا تدعم ++C البرمجة كائنية التوجه فقط بل تدعم أيضاً نماذجاً برمجية أخرى ضعيفة التفكك مثل البرمجة التركيبية.

يعتبر جعل كافة الأعضاء البيانية خاصةً (أو محمية) بالإضافة إلى جعل فقط تلك التوابع التي توفر واجهة أصغرية لبقية مستخدمي الصف عامةً من الممارسات البرمجية الجيدة إجمالاً. ذلك أنه يمكن إخفاء تفاصيل تحقيق وظيفية الصف بهذه الطريقة بشكل يتيح للمصممين إمكانية تغيير التحقيق بشكل كامل لاحقاً دون الاضطرار إلى تغيير الواجهة التي يستخدمها الآخرون .

تتيح الوراثة لنمط بيانات ما أن يكتسب خصائص نمط بيانات آخر. يمكن للوراثة من صف القاعدي (أو الصف الأب) أن تعرف كوراثة عامة codice_19 أو محمية codice_20 أو خاصة codice_21. تتيح معرفات الوصول هذه تحديد فيما إذا كانت الصفوف المشتقة وعديمة الصلة تستطيع الولوج إلى الأعضاء العامة والمحمية الخاصة بالصف القاعدي. إن الوراثة العامة فقط هي التي تتناسب مع المعنى المقصود عادةً بالـ"وراثة" ويعتبر النوعان المتبقيان أقل استخداماً بشكل كبير. في حال تم حذف معرف الوصول تكون الوراثة بين "الصف" المشتق و"الصف" القاعدي خاصة في حين تكون الوراثة بين "البنية" (codice_22) المشتقة و"البنية" الأب عامة. يمكن تعريف الصفوف القاعدية كصفوف وهمية codice_23؛ في هذه الحالة تسمى الوراثة وهمية. تضمن الوراثة الوهمية وجود نموذج (instance) واحد فقط من الصف القاعدي في بيان الوراثة بشكل يجلي الغموض الذي قد يحصل بسبب الوراثة المتعددة.

إن الوراثة المتعددة هي ميزة تكاد تنفرد بها لغة ++C إذ لا توجد هذه الميزة في أغلب لغات البرمجة الأخرى، تتيح الوراثة المتعددة لصف ما أن يُشتق من أكثر من صف قاعدي واحد؛ تتيح هذه الميزة إنشاء علاقات وراثية أكثر دقة. فعلى سبيل المثال يمكن لصف "القط الطائر" أن يرث من كلا الصفين "قط" و"لبون طائر". بعض اللغات الأخرى مثل لغة Java ولغة #C تحقق هدفاً شبيهاً (على الرغم من كونه محدوداً أكثر) عبر إتاحة الوراثة من واجهات متعددة في حين حصر عدد الصفوف القاعدية بصف واحد فقط (تتيح الواجهات -على خلاف الصفوف- إمكانية التصريح عن التوابع الأعضاء دون إمكانية إضافة تحقيق لها أو إضافة أعضاء بيانية). يمكن تعريف واجهة كما في لغة #C ولغة Java في لغة ++C أيضاً كصف يحتوي فقط على توابع ظاهرية صرفة (pure virtual)، يعرف هكذا الصف باسم "صف قاعدي مجرد" (ABC) . تعرّف التوابع الأعضاء الخاصة بصف قاعدي مجرد عادةً بشكل صريح في الصف المشتق ولا يتم توريثها ضمنياً. تتمتع الوراثة الظاهرية في لغة ++C بميزة إجلاءٍ للغموض اسمها الهيمنة .

يتيح تعدد الأشكال توفير واجهة مشتركة لتحقيقات (implementation) عديدة، كما تتيح للكائنات أن تتصرف بطرق مختلفة حسب الأوضاع المختلفة. توفر ++C العديد من أنواع تعددية الأشكال السكونية (وقت التصريف) والديناميكية (وقت التنفيذ). في حين لا تتيح "تعددية أشكال وقت التصريف" اتخاذ بعض القرارات أثناء التنفيذ تنطوي "تعددية أشكال وقت التنفيذ" على بطء نسبي في الأداء.

يمكّن التحميل الزائد للتوابع من كتابة توابع تحمل الاسم نفسه (ولكن لها وسائط مختلفة). يتم تمييز التوابع عن بعضها البعض من خلال عدد وأنماط بارامتراتها. لهذا السبب قد يشير اسم التابع ذاته إلى توابع مختلفة حسب السياق الذي يتم استخدامه به. من الجدير بالملاحظة أن نمط القيمة المعادة للتابع لا يستخدم للتفريق بين التوابع المحملة بشكل زائد وبؤدي في حال اعتماده إلى رسالة خطأ أثناء ترجمة البرنامج.

لدى التصريح عن تابع ما يمكن للمبرمج أن يسند لبارامتر واحد أو أكثر قيمة افتراضية. في حال القيام بذلك يمكن إهمال هذه البارامترات لدى استدعاء التابع ليتم تعويضها بقيمها الافتراضية. عند استدعاء تابع باستخدام عدد من الوسطاء أقل من عدد البارامترات المصرح عنها يتم مطابقة الوسطاء الممررة مع البارامترات الموافقة لها من اليسار إلى اليمين ومن ثم يتم إعطاء أي بارامتر لم تتم مطابقته قيمته الافتراضية. في الكثير من الحالات يفضل استخدام تصريح واحد للتابع مع قيم افتراضية بدلاً من توفير عدد من التوابع المعرفة بشكل زائد لديها أعداد وأنماط مختلفة من البارامترات.

توفر قوالب لغة ++C تقنية متطورة ومعقدة لكتابة كود عمومي متعدد الأشكال. تحديداً يتيح "نمط القالب غريب التكرار" كتابة نماذج من تعدد الأشكال السكوني تحاكي بشكل قريب أسلوب كتابة تجاوز التوابع الظاهرية. تستطيع قوالب ++C التعرف على الأنماط وتتمتع بكونها تورينغ-كاملة، تمكّن هاتين الميزتين من استخدام المصرّف لحل الشرطية العودية وتوليد برامج هامة باستخدام ميتا-برمجة القوالب. خلافاً للمعتقد السائد فإن استخدام القوالب لا يولد كوداً عديم الفائدة عند التصريف بشرط استخدام الإعدادات المناسبة للمصرف.

تستطيع المتحولات من نمط المؤشرات (والأدلة) التي تشير إلى صف قاعدي أن تشير أيضاً إلى أي كائن من نمط صف مشتق من ذاك الصف القاعدي بالإضافة إلى الكائنات التي تطابق نمط المتحول. تمنح هذه الميزة مصفوفات وحاويات المؤشرات إمكانية الإشارة إلى كائنات من أنماط مختلفة. يحدث هذا السلوك وقت التنفيذ عادةً ذلك أن المتحولات غالباً ما تسند لها القيم وقت التنفيذ.

توفر ++C المعامل codice_24 الذي يتيح للبرنامج أن يحاول بأمان (بدون أخطاء) تحويل نمط كائن إلى نمط آخر أكثر تحديداً (على خلاف التحويل إلى نمط أكثر عمومية المسموح دائماً). تعتمد هذه الميزة على معلومات التنميط وقت التنفيذ (RTTI) . يمكن للكائنات التي يعرف المبرمج سلفاً أنها من نمط معين أن تُحول إلى ذلك النمط باستخدام المعامل codice_25 الذي يتم التحقق منه وقت التصريف ولا ينطوي على أي جهد إضافي وقت التنفيذ كما أنه لا يتطلب RTTI.

بشكل عام عندما يتجاوز تابع من صف مشتق تابعاً من صف قاعدي يحدد الإصدار الواجب استدعائه من ذلك التابع حسب نمط الكائن. يتم تجاوز تابع ما عندما لا يوجد اختلاف في عدد وأنماط الوسائط بين تعريفين أو أكثر من للتابع. بما أنه قد لا يمكن معرفة نمط الكائن المشار إليه بدقة وقت التصريف في حال استخدام متحول من نمط مؤشر إلى صف قاعدي فإنه المصرف لن يعرف في هذه المرحلة أي نسخة من التابع يجب استدعاؤها؛ لهذا السبب يؤجل هذا القرار إلى حين وقت التنفيذ وتسمى هذه السياسة "الترحيل الديناميكي" . تتيح التوابع الأعضاء الظاهرية أو "الطرق" استدعاء النحقيق الأكثر تحديداً من التابع المُستدعى حسب نمط الكائن وقت التنفيذ. يتم تحقيق هذا الغرض بشكل شائع في تحقيقات لغة ++C عن طريق استخدام جداول التوابع الظاهرية. يمكن تجاوز استخدام جداول التوابع الظاهرية بإضافة الاسم المؤهل الكامل للصف قبل استدعاء التابع في حال معرفة نمط الكائن إلا أن الاستدعاءات العامة للتوابع الظاهرية يتم حلها وقت التنفيذ باستخدام هذه الجداول.

بالإضافة إلى التوابع الأعضاء القياسية يمكن لتوابع التحميل الزائد للمعاملات والهوادم أن تكون ظاهرية أيضاً. تقول القاعدة العامة أنه في حال وجود تابع عضو ظاهري واحد على الأقل في الصف يجب أن يكون هادم الصف ظاهرياً أيضاً. بما أن نمط التابع وقت إنشائه يكون معروفاً وقت التصريف فإن البواني (وكذلك البواني الناسخة) لا يمكن أن تكون ظاهرية. على الرغم من ذلك قد تظهر بعض الحالات التي يضطر فيها إنشاء نسخة من الكائن عند تمرير مؤشر إلى كائن مشتق كمؤشر إلى كائن قاعدي. الحل الشائع لحالة كهذه يمكن في إنشاء تابع ظاهري codice_26 (أو أي اسم آخر) ينشئ ويعيد نسخةً من الصف المشتق لدى استدعائه.

يمكن للتابع العضو أن يكون "ظاهرياً صرفاً" من خلال إضافة 0= في نهاية التصريح عن التابع وقبل الفاصلة المنقوطة. يسمى الصف الذي يحتوي تابعاً عضواً ظاهرياً صرفاً واحداً على الأقل باسم نمط بيانات مجرد. لا يمكن إنشاء كائنات من أنماط البيانات المجردة. يمكن فقط اشتقاق أنماط البيانات المجردة. أي صف مشتق يرث تابعاً ظاهرياً صرفاً (أو أكثر) يجب أن يوفر تعريفاً غير-صرفٍ له لكي يمكن إنشاء كائنات منه. أي برنامج يحاول إنشاء كائنات من صف يحوي تابعاً ظاهرياً صرفاً أو يرث تابعاً ظاهرياً صرفاً (دون توفير تعريف غير-صرف له) هو برنامج سيئ التشكيل بالنسبة لقواعد كتابة برنامج باستخدام ++C.

إن كتابة مجزئ باستخدام إحدى خوارزميات التجزيء الكلاسيكية كخوارزمية المجزئ يسار يمين أمامي (1)LALR مهمة صعبة نسبياً. يعود السبب في ذلك جزئياً إلى أن قواعد لغة ++C ليست في الحقيقة LALR. نتيجة ذلك يوجد عدد محدود جداً من الأدوات القادرة على معالجة الكود وإجراء تحويلات غير بديهية عليه (كإعادة هيكلة الكود مثلاً). إحدى طرق التغلب على هذه الصعوبة تمكن في اختيار نحو مختلف. يمكن لبعض المجزئات الفعالة مثل مجزئ يسار يمين المعمم القيام بتجزئة الكود بسهولة (إلا أنها أبطأ).

إن التجزيء (بمعنى بناء شجرة نحوية) ليس أصعب المهام اللازمة لبناء أداة معالجة كود ++C. إذ يجب على أدوات كهذه الإلمام بمعاني المعرّفات المستخدمة في البرنامج تماماً كما يفعل المصرف. يجب على الأنظمة الفعالة التي تعالج كود ++C أن لا تقوم فقط بتجزيء النص المصدري، بل يجب عليها أيضاً أن تنسب كل معرف إلى التعريف المناسب له تماماً وفق السياق (على سبيل المثال يجب عليها أن تتعامل بشكل صحيح مع قواعد نطاقات التسمية المعقدة) كما يجب عليها أن تقرر نمط المعرف وكذلك أنماط التعابير المركبة.

أخيراً يجب أن تستطيع أداة معالجة كود ++C التعامل مع عدد من لهجات ++C المستخدمة بشكل شائع (مثل تلك المدعومة من قبل GNU Compiler Collection و++Microsoft Visual C) وأن توفر المحللات وتحويلات الكود وإعادة توليد الكود المصدري المناسب لها. إن الدمج بين خوارزميات المتطورة مثل خوارزمية مجزئ يسار يمين المعمم مع جداول الرموز وتقنية تحويل النصوص المصدرية يتيح بناء كافة أدوات معالجة ++C. توفر جميع المصرفات أدواتاً للتجزيء. على الرغم من أن هنالك مصرف وحيد فقط يوفر مجزئاً يتمتع بالمرونة الكافية لدمجه مع أدوات الأخرى وهو Clang حيث يمكن استخدام المجزئ الخاص به كمكتبة ++C (أو C) جاهزة للاندماج في أدوات أخرى كبيئة تطوير متكاملة مثلاً.

يواجه منتجو المصرفات صعوبات جمة في بناء مصرف متوافق بشكل كامل مع معيار ++C. فقد طبقت العديد من المصرفات لسنواتٍ كثيرة لغة ++C بمستويات متفاوتة من ناحية التوافق مع المعيار، وقد اختلفت أساليب تحقيق بعض جوانب اللغة مثل تخصيص القوالب الجزئي فيما بينها إلى درجة عالية. تدعم الإصدارات الحديثة لمعظم مصرفات ++C الشهيرة أغلبية معيار C++ 1998.

لم تملِ لجنة معيار ++C كيفية تحقيق تغيير أسماء الرموز ومعالجة الاستثناءات ومزايا أخرى متعلقة بالتحقيق بهدف إعطاء منتجي المصرفات حرية أكبر في بناء مصرفاتهم. إن الجانب السلبي من هذا القرار هو أن الكود الكائني الذي تنتجه المصرفات المختلفة سيكون مختلفاً وغير متوافق على الأغلب. مع ذلك كان هناك عدة محاولات لتعيير المصرفات التي تعمل على أجهزة وأنظمة تشغيل محددة (على سبيل المثال مقاربة C++ ABI ) على الرغم من أن أغلبها يبدو مهملاً الآن.

تعتبر الكلمة المفتاحية codice_27 إحدى النقاط التي ساد حولها خلاف كبير. تهدف هذه الكلمة المفتاحية إلى إتاحة إمكانية فصل التصريح عن القوالب عن تعريفها. تأخر تحقيق هذه الميزة حتى عام 2003، أي بعد خمس سنوات من نشر المعيار، وكان ++Cameau C/C أول مصرف يقوم بذلك؛ خلال عام 2004 طُرحت النسخة بيتا من المصرف Borland C++ Builder X مع دعم للكلمة المفتاحية codice_27. كلا المصرفان مبنيان على الواجهة الأمامية من المصرف ++EDG C. في حين لا تدعم العديد من المصرفات كـGCC هذه الميزة أساساً.

في كتاب ++Beginning ANSI C يقدم المؤلف إيفور هورتون مثالاً عن كود ++C يستخدم فيه هذه الكلمة المفتاحية بحيث لا يعمل على أغلب المصرفات دون الإشارة صراحة إلى السبب في ذلك. لقد أوصى المدير السابق للجنة معيار ++C هيرب شتر إلى ضرورة إزالة هذه الكلمة المفتاحية من الإصدارات المستقبلية لمعيار ++C بهدف حسم هذه المعضلة بشكل نهائي . وبالفعل فقد قررت لجنة معيار ++C خلال اجتماعها في 10 آذار 2010 إزالة مفهوم القوالب المصدّرة بشكل كامل من المعيار C++11 إلا أنها قررت الإبقاء على الكلمة المفتاحية codice_27 من أجل الاستعمال المستقبلي.

غالباً ما يتم اعتبار لغة ++C أنها تشتمل على لغة C إلا أن هذا الاعتبار ليس تام الصحة. من الممكن القيام بتصريف أغلب الكود المكتوب بلغة C ضمن بيئة ++C بشكل صحيح إلا أن هذا لا ينفي وجود بعض الاختلافات التي تجعل بعض الكود المكتوب بشكل شرعي بلغة C غير صحيح أو مختلف الأداء ضمن بيئة ++C.

أحد الاختلافات الشهيرة بين اللغتين هو قيام لغة C بالتحويل ضمنياً للنمط codice_30 إلى أنماط مؤشرات أخرى في حين لا تقوم ++C بذلك (بهدف تعزيز ميزة التنميط الآمن). توجد أيضاً مشكلات في المحمولية بين اللغتين إذ تعرف لغة ++C العديد من الكلمات المفتاحية الجديدة مثل codice_14 وcodice_32 والتي يمكن استخدامها كمعرّفات (أسماء متحولات على سبيل المثال) في برنامج مكتوب بلغة C.

لقد أزيلت بعض عقبات عدم التوافقية في تنقيح معيار لغة C (المسمى C99) الذي تم عام 1999، حيث أضيفت بعض ميزات ++C إلى لغة C كالتعليقات السطرية (codice_33) وإمكانية الدمج بين التصاريح وبقية أجزاء الكود. في نفس الوقت أدخل المعيار C99 عدداً من الميزات الجديدة التي لا تدعمها لغة ++C مسببة عدم التوافق أو أنها موجودة في لغة ++C ولكن بأسلوب آخر مسببة زيادةً غير مرغوبة، على سبيل المثال تعرف C99 النمط codice_34 المعرف بلغة ++C بالصف complex الموجود ضمن مكتبة ++C القياسية، كذلك دعم C99 للمصفوفات ذات الأبعاد المتغيرة وتعريفها النمط codice_35 كـاسم مستعار بـcodice_36 في حين أنه نمط بيانات أساسي في لغة ++C، إضافة إلى إضافة الكلمة المفتاحية codice_37. أٌدخلت بعض ميزات C99 الجديدة في الإصدار التالي من معيار ++C وهو C++11 :
إن دمج كود C مع كود ++C يتطلب أن يسبق تصريح أي تابع يتم التعامل معه من اللغتين معلومةً تشير إلى ضرورة استخدام C للقيام بربطه مع بقية البرنامج (يتم ذلك عبر استخدام codice_47) تفادياً لاستخدام تقنية ربط ++C التي تغير اسم التابع (بهدف تمييز التوابع المحملة بشكل زائد عن بعضها).




</doc>